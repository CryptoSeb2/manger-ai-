//@version=6
// Volume Math Trade Signals + S/R Zones (combined)

indicator("Volume Math and S/R Zones", shorttitle="VM+SR", overlay=true, max_lines_count=100, max_labels_count=100, max_boxes_count=50)

// ═══════════════════════════════════════════════════════════════════════════════
// INPUTS
// ═══════════════════════════════════════════════════════════════════════════════

ma_fast_len   = input.int(9,   "Fast MA Length",     minval=1, group="Math")
ma_slow_len   = input.int(21,  "Slow MA Length",     minval=1, group="Math")
rsi_len       = input.int(14,  "RSI Length",         minval=1, group="Math")
rsi_ob        = input.int(70,  "RSI Overbought",     minval=50, maxval=100, group="Math")
rsi_os        = input.int(30,  "RSI Oversold",       minval=0,  maxval=50, group="Math")
use_rsi       = input.bool(true, "Use RSI Filter", group="Math")

vol_ma_len    = input.int(20,  "Volume MA Length",   minval=1, group="Volume")
vol_mult      = input.float(1.2, "Volume Confirmation Multiplier", minval=0.5, step=0.1, group="Volume")
require_vol   = input.bool(true, "Require Volume Confirmation", group="Volume")
use_vwap      = input.bool(true, "Use VWAP for Trend", group="Volume")

// Core quant math (built into signal for accuracy)
use_atr_core  = input.bool(true, "Quant: ATR volatility filter (skip extreme vol)", group="Quant Core")
atr_len       = input.int(14,  "ATR Length",         minval=1, group="Quant Core")
atr_min_mult  = input.float(0.5, "Min ATR vs avg (skip dead market)", minval=0, step=0.1, group="Quant Core")
atr_max_mult  = input.float(3.0, "Max ATR vs avg (skip chaos)", minval=1, step=0.5, group="Quant Core")
atr_bench     = input.int(20,  "ATR benchmark MA length", minval=1, group="Quant Core")
use_zscore_core = input.bool(true, "Quant: Z-score filter (skip extreme price)", group="Quant Core")
z_len         = input.int(20,  "Z-Score length",    minval=2, group="Quant Core")
z_thresh      = input.float(2.0, "Z-Score threshold", minval=0.5, step=0.5, group="Quant Core")

use_bb       = input.bool(true, "Use Bollinger Bands Filter", group="Extra Math")
bb_len       = input.int(20,   "Bollinger Length",   minval=1, group="Extra Math")
bb_mult      = input.float(2.0, "Bollinger Std Dev", minval=0.5, step=0.1, group="Extra Math")
use_macd     = input.bool(true, "Use MACD Filter", group="Extra Math")
macd_fast    = input.int(12,   "MACD Fast",         minval=1, group="Extra Math")
macd_slow    = input.int(26,   "MACD Slow",         minval=1, group="Extra Math")
macd_signal  = input.int(9,    "MACD Signal",       minval=1, group="Extra Math")
use_lr       = input.bool(true, "Use Linear Regression Trend", group="Extra Math")
lr_len       = input.int(20,   "Regression Length", minval=2, group="Extra Math")

use_session   = input.bool(true,  "Session Filter (market open)", group="Intraday")
session_start = input.int(1800, "Session Start (HHMM)", minval=0, maxval=2359, group="Intraday")
session_end   = input.int(1700, "Session End (HHMM)", minval=0, maxval=2359, group="Intraday")
min_bars_btw  = input.int(3,   "Min Bars Between Signals", minval=0, group="Intraday")
use_close_confirm = input.bool(true, "Candle Close Confirmation", group="Intraday")
use_htf_trend = input.bool(true, "Higher Timeframe Trend Filter", group="Intraday")
htf_timeframe = input.timeframe("15", "HTF Timeframe", group="Intraday")
avoid_first_min = input.int(0,  "Avoid First N Minutes of Session", minval=0, maxval=60, group="Intraday")

show_arrows   = input.bool(true, "Show Signal Arrows", group="Display")
show_labels   = input.bool(true, "Show Signal Labels", group="Display")

// S/R Zones (from Volume Support & Resistance indicator)
vp_lookback   = input.int(50,   "Profile Lookback (bars)", minval=10, group="S/R Zones")
vp_bins       = input.int(50,   "Price Bins (resolution)", minval=20, maxval=100, group="S/R Zones")
vp_value_pct  = input.float(70, "Value Area % (e.g. 70 = 70% of volume)", minval=50, maxval=90, step=5, group="S/R Zones")
show_poc      = input.bool(true, "Show POC (Point of Control)", group="S/R Zones")
show_vah_val  = input.bool(true, "Show VAH / VAL (Value Area High/Low)", group="S/R Zones")
show_va_rect  = input.bool(true, "Show Value Area Rectangle", group="S/R Zones")
show_support_zone   = input.bool(true, "Show Support Zone Rectangle (below VAL)", group="S/R Zones")
show_resistance_zone = input.bool(true, "Show Resistance Zone Rectangle (above VAH)", group="S/R Zones")
zone_ext_pct  = input.float(15, "Zone Extension % (of value area height)", minval=5, maxval=50, step=5, group="S/R Zones")
show_zone_labels = input.bool(true, "Show zone labels", group="S/R Zones")
zone_label_sz = input.string("small", "Zone label size", options=["tiny", "small", "normal"], group="S/R Zones")
use_zone_confirm = input.bool(true, "Require zone confirmation for signals (LONG only when price not in resistance; SHORT only when not in support)", group="S/R Zones")
poc_color   = input.color(color.yellow, "POC Color", group="S/R Zones")
vah_color   = input.color(color.green,  "VAH Color", group="S/R Zones")
val_color   = input.color(color.red,    "VAL Color", group="S/R Zones")
va_fill     = input.color(color.new(color.green, 90), "Value Area Fill", group="S/R Zones")
support_fill = input.color(color.new(color.green, 88), "Support Zone Fill", group="S/R Zones")
resistance_fill = input.color(color.new(color.red, 88), "Resistance Zone Fill", group="S/R Zones")

// ORB (Opening Range Breakout) — build for every session (choose which)
orb_session    = input.string("8:00 AM NY (8:00-8:15)", "ORB Session (built every time it starts)", options=["8:00 AM NY (8:00-8:15)", "Same as Intraday", "CME (18:00-17:00 NY)", "RTH (9:30-16:00 NY)", "Both CME and RTH"], group="ORB")
orb_minutes    = input.int(15,  "ORB: First N minutes (8am = 15 = one 15m candle wick-to-wick)", minval=5, maxval=60, group="ORB")
orb_calc_tf    = input.timeframe("15", "ORB built on this TF (same on all charts)", group="ORB", options=["", "1", "3", "5", "15", "30", "60"], tooltip="15 = ORB always from 15m (same on 1m, 5m, 1H, etc.). Blank = use chart TF (ORB changes with chart).")
show_orb_lines = input.bool(true, "Show ORB High / Low lines", group="ORB")
show_orb_rect  = input.bool(true, "Show ORB range rectangle (whole range shaded)", group="ORB")
orb_rect_fill  = input.color(color.new(color.blue, 88), "ORB rectangle fill", group="ORB")
orb_rect_border = input.color(color.new(color.blue, 50), "ORB rectangle border", group="ORB")
show_orb_signal = input.bool(true, "Show ORB breakout signals (LONG/SHORT on break)", group="ORB")
vm_only_after_orb = input.bool(true, "VM signals only after ORB break (LONG above ORB high, SHORT below ORB low)", group="ORB")
orb_high_color = input.color(color.new(color.blue, 0), "ORB High color", group="ORB")
orb_low_color  = input.color(color.new(color.orange, 0), "ORB Low color", group="ORB")
orb_rth_high_color = input.color(color.new(color.teal, 0), "ORB RTH High color (when Both)", group="ORB")
orb_rth_low_color  = input.color(color.new(color.maroon, 0), "ORB RTH Low color (when Both)", group="ORB")

alert_on_signal = input.bool(true, "Create Alert on Signal", group="Alerts")

// ═══════════════════════════════════════════════════════════════════════════════
// MATH: MAs, RSI
// ═══════════════════════════════════════════════════════════════════════════════

ma_fast = ta.sma(close, ma_fast_len)
ma_slow = ta.sma(close, ma_slow_len)
bull_cross = ta.crossover(ma_fast, ma_slow)
bear_cross = ta.crossunder(ma_fast, ma_slow)
rsi = ta.rsi(close, rsi_len)
ma_bullish = ma_fast > ma_slow
ma_bearish = ma_fast < ma_slow
rsi_ok_long  = not use_rsi or (rsi > rsi_os and rsi < rsi_ob)
rsi_ok_short = not use_rsi or (rsi > rsi_os)
rsi_favors_long  = use_rsi and rsi < rsi_os
rsi_favors_short = use_rsi and rsi > rsi_ob
rsi_cross_up   = ta.crossover(rsi, rsi_os)
rsi_cross_down = ta.crossunder(rsi, rsi_ob)

// ═══════════════════════════════════════════════════════════════════════════════
// VOLUME & VWAP
// ═══════════════════════════════════════════════════════════════════════════════

vol_ma = ta.sma(volume, vol_ma_len)
volume_confirmed = volume >= vol_ma * vol_mult
volume_ok = not require_vol or volume_confirmed

var float cum_vol = 0.0
var float cum_vol_price = 0.0
new_day = ta.change(time("D")) != 0
if new_day
    cum_vol := volume
    cum_vol_price := close * volume
else
    cum_vol += volume
    cum_vol_price += close * volume
vwap_daily = cum_vol_price / cum_vol
price_above_vwap = close > vwap_daily
price_below_vwap = close < vwap_daily
vwap_bullish = not use_vwap or price_above_vwap
vwap_bearish = not use_vwap or price_below_vwap

// ═══════════════════════════════════════════════════════════════════════════════
// QUANT CORE: ATR volatility + Z-Score (built into signal for accuracy)
// ═══════════════════════════════════════════════════════════════════════════════

atr_val   = ta.atr(atr_len)
atr_ma    = ta.sma(atr_val, atr_bench)
atr_ratio = atr_val / math.max(atr_ma, 1e-8)
atr_ok    = not use_atr_core or (atr_ratio >= atr_min_mult and atr_ratio <= atr_max_mult)

z_mean  = ta.sma(close, z_len)
z_std   = ta.stdev(close, z_len)
z_score = z_std > 0 ? (close - z_mean) / z_std : 0.0
z_ok_long  = not use_zscore_core or z_score < z_thresh
z_ok_short = not use_zscore_core or z_score > -z_thresh

// ═══════════════════════════════════════════════════════════════════════════════
// EXTRA MATH: Bollinger, MACD, Regression
// ═══════════════════════════════════════════════════════════════════════════════

bb_basis = ta.sma(close, bb_len)
bb_dev   = bb_mult * ta.stdev(close, bb_len)
bb_upper = bb_basis + bb_dev
bb_lower = bb_basis - bb_dev
bb_cross_up   = ta.crossover(close, bb_lower)
bb_cross_down = ta.crossunder(close, bb_upper)
bb_in_range_long  = bb_cross_up or (close >= bb_lower and close <= bb_upper)
bb_in_range_short = bb_cross_down or (close <= bb_upper and close >= bb_lower)
bb_ok_long  = not use_bb or bb_in_range_long
bb_ok_short = not use_bb or bb_in_range_short

[macd_line, macd_sig, macd_hist] = ta.macd(close, macd_fast, macd_slow, macd_signal)
macd_bullish = not use_macd or macd_line >= macd_sig
macd_bearish = not use_macd or macd_line <= macd_sig

lr_slope = ta.linreg(close, lr_len, 0) - ta.linreg(close, lr_len, 1)
lr_ok_long  = not use_lr or lr_slope >= 0
lr_ok_short = not use_lr or lr_slope <= 0

// ═══════════════════════════════════════════════════════════════════════════════
// INTRADAY: Session, min bars, close confirm, HTF
// ═══════════════════════════════════════════════════════════════════════════════

h = hour(time, "America/New_York")
m = minute(time, "America/New_York")
hhmm = h * 100 + m
session_start_min = math.floor(session_start / 100) * 60 + (session_start % 100)
effective_start_min = session_start_min + avoid_first_min
effective_start_hhmm = math.floor(effective_start_min / 60) * 100 + (effective_start_min % 60)
in_session = not use_session or (session_end < session_start ? (hhmm >= effective_start_hhmm or hhmm <= session_end) : (hhmm >= effective_start_hhmm and hhmm <= session_end))

var int last_long_bar  = -100
var int last_short_bar = -100
bars_since_long  = bar_index - last_long_bar
bars_since_short = bar_index - last_short_bar
min_bars_ok_long  = (min_bars_btw <= 0) or (bars_since_long >= min_bars_btw and bars_since_short >= min_bars_btw)
min_bars_ok_short = min_bars_ok_long

close_confirm_long  = not use_close_confirm or close > ma_fast
close_confirm_short = not use_close_confirm or close < ma_fast

[htf_fast, htf_slow] = request.security(syminfo.tickerid, htf_timeframe, [ta.sma(close, ma_fast_len), ta.sma(close, ma_slow_len)], lookahead=barmerge.lookahead_off)
htf_bullish = not use_htf_trend or htf_fast > htf_slow
htf_bearish = not use_htf_trend or htf_fast < htf_slow

// ═══════════════════════════════════════════════════════════════════════════════
// ORB (Opening Range Breakout): high/low of first N minutes — built for EVERY session
// Session definitions (America/New_York): CME 18:00-17:00, RTH 9:30-16:00
// ═══════════════════════════════════════════════════════════════════════════════

in_cme = (hhmm >= 1800 or hhmm <= 1700)
in_rth = (hhmm >= 930 and hhmm <= 1600)
in_8am = (hhmm >= 800)
in_orb_session = orb_session == "8:00 AM NY (8:00-8:15)" ? in_8am : orb_session == "Same as Intraday" ? in_session : orb_session == "CME (18:00-17:00 NY)" ? in_cme : orb_session == "RTH (9:30-16:00 NY)" ? in_rth : in_cme
in_orb_session_rth = in_rth
use_both_orb = (orb_session == "Both CME and RTH")

use_fixed_tf_orb = (str.length(orb_calc_tf) > 0) and not use_both_orb
f_orb_htf_high() =>
    var float o_high = na
    var float o_low = na
    var int o_done = 999
    int _h = hour(time, "America/New_York")
    int _m = minute(time, "America/New_York")
    int _hhmm = _h * 100 + _m
    bool _in_cme = (_hhmm >= 1800 or _hhmm <= 1700)
    bool _in_rth = (_hhmm >= 930 and _hhmm <= 1600)
    bool _in_sess = session_end < session_start ? (_hhmm >= session_start or _hhmm <= session_end) : (_hhmm >= session_start and _hhmm <= session_end)
    bool _in_8am = (_hhmm >= 800)
    bool _in_orb_sess = orb_session == "8:00 AM NY (8:00-8:15)" ? _in_8am : orb_session == "Same as Intraday" ? _in_sess : orb_session == "CME (18:00-17:00 NY)" ? _in_cme : orb_session == "RTH (9:30-16:00 NY)" ? _in_rth : _in_cme
    bool _new_sess = _in_orb_sess and not _in_orb_sess[1]
    int _bars_in_orb = math.max(1, int(orb_minutes * 60.0 / math.max(1, timeframe.in_seconds())))
    if _new_sess
        o_high := high
        o_low := low
        o_done := 1
    else if _in_orb_sess and o_done < _bars_in_orb
        o_high := math.max(o_high, high)
        o_low := math.min(o_low, low)
        o_done += 1
    o_high
f_orb_htf_low() =>
    var float o_high = na
    var float o_low = na
    var int o_done = 999
    int _h = hour(time, "America/New_York")
    int _m = minute(time, "America/New_York")
    int _hhmm = _h * 100 + _m
    bool _in_cme = (_hhmm >= 1800 or _hhmm <= 1700)
    bool _in_rth = (_hhmm >= 930 and _hhmm <= 1600)
    bool _in_sess = session_end < session_start ? (_hhmm >= session_start or _hhmm <= session_end) : (_hhmm >= session_start and _hhmm <= session_end)
    bool _in_8am = (_hhmm >= 800)
    bool _in_orb_sess = orb_session == "8:00 AM NY (8:00-8:15)" ? _in_8am : orb_session == "Same as Intraday" ? _in_sess : orb_session == "CME (18:00-17:00 NY)" ? _in_cme : orb_session == "RTH (9:30-16:00 NY)" ? _in_rth : _in_cme
    bool _new_sess = _in_orb_sess and not _in_orb_sess[1]
    int _bars_in_orb = math.max(1, int(orb_minutes * 60.0 / math.max(1, timeframe.in_seconds())))
    if _new_sess
        o_high := high
        o_low := low
        o_done := 1
    else if _in_orb_sess and o_done < _bars_in_orb
        o_high := math.max(o_high, high)
        o_low := math.min(o_low, low)
        o_done += 1
    o_low

orb_high_htf = use_fixed_tf_orb ? request.security(syminfo.tickerid, orb_calc_tf, f_orb_htf_high(), lookahead=barmerge.lookahead_off) : na
orb_low_htf  = use_fixed_tf_orb ? request.security(syminfo.tickerid, orb_calc_tf, f_orb_htf_low(), lookahead=barmerge.lookahead_off) : na

bars_in_orb = math.max(1, int(orb_minutes * 60.0 / math.max(1, timeframe.in_seconds())))

// ---- Single-session ORB (Same / CME only / RTH only) ----
new_session_bar = in_orb_session and not in_orb_session[1]
var float orb_high = na
var float orb_low = na
var int orb_bars_done = 999
if not use_both_orb
    if new_session_bar
        orb_high := high
        orb_low := low
        orb_bars_done := 1
    else if in_orb_session and orb_bars_done < bars_in_orb
        orb_high := math.max(orb_high, high)
        orb_low := math.min(orb_low, low)
        orb_bars_done += 1

// ---- Both CME and RTH: two ORBs, built every time each session starts ----
new_cme_bar = in_cme and not in_cme[1]
new_rth_bar = in_rth and not in_rth[1]
var float orb_high_cme = na
var float orb_low_cme = na
var int orb_cme_bars_done = 999
var float orb_high_rth = na
var float orb_low_rth = na
var int orb_rth_bars_done = 999
if use_both_orb
    if new_cme_bar
        orb_high_cme := high
        orb_low_cme := low
        orb_cme_bars_done := 1
    else if in_cme and orb_cme_bars_done < bars_in_orb
        orb_high_cme := math.max(orb_high_cme, high)
        orb_low_cme := math.min(orb_low_cme, low)
        orb_cme_bars_done += 1
    if new_rth_bar
        orb_high_rth := high
        orb_low_rth := low
        orb_rth_bars_done := 1
    else if in_rth and orb_rth_bars_done < bars_in_orb
        orb_high_rth := math.max(orb_high_rth, high)
        orb_low_rth := math.min(orb_low_rth, low)
        orb_rth_bars_done += 1

// ORB range start time (for rectangle: use time so box works when far from current bar)
var int orb_range_start_time = na
if new_session_bar and not use_both_orb
    orb_range_start_time := time
var int orb_range_start_cme = na
var int orb_range_start_rth = na
if new_cme_bar and use_both_orb
    orb_range_start_cme := time
if new_rth_bar and use_both_orb
    orb_range_start_rth := time

// Effective ORB levels (use fixed-TF result when set so ORB same on all timeframes)
orb_high_1 = use_fixed_tf_orb ? orb_high_htf : orb_high
orb_low_1  = use_fixed_tf_orb ? orb_low_htf : orb_low
orb_high_eff = use_both_orb ? (in_rth ? orb_high_rth : orb_high_cme) : orb_high_1
orb_low_eff  = use_both_orb ? (in_rth ? orb_low_rth : orb_low_cme) : orb_low_1
above_orb_high = not na(orb_high_eff) and close > orb_high_eff
below_orb_low  = not na(orb_low_eff) and close < orb_low_eff

// Breakout signals: single session
orb_long_break  = above_orb_high and close[1] <= orb_high_eff and in_orb_session and not use_both_orb
orb_short_break = below_orb_low and close[1] >= orb_low_eff and in_orb_session and not use_both_orb
// Breakout signals: Both (CME break in CME session, RTH break in RTH session)
above_cme = not na(orb_high_cme) and close > orb_high_cme
below_cme = not na(orb_low_cme) and close < orb_low_cme
above_rth = not na(orb_high_rth) and close > orb_high_rth
below_rth = not na(orb_low_rth) and close < orb_low_rth
orb_long_break_cme  = use_both_orb and in_cme and above_cme and close[1] <= orb_high_cme
orb_short_break_cme = use_both_orb and in_cme and below_cme and close[1] >= orb_low_cme
orb_long_break_rth  = use_both_orb and in_rth and above_rth and close[1] <= orb_high_rth
orb_short_break_rth = use_both_orb and in_rth and below_rth and close[1] >= orb_low_rth

var bool orb_long_done = false
var bool orb_short_done = false
var bool orb_long_done_cme = false
var bool orb_short_done_cme = false
var bool orb_long_done_rth = false
var bool orb_short_done_rth = false
if new_session_bar and not use_both_orb
    orb_long_done := false
    orb_short_done := false
if new_cme_bar and use_both_orb
    orb_long_done_cme := false
    orb_short_done_cme := false
if new_rth_bar and use_both_orb
    orb_long_done_rth := false
    orb_short_done_rth := false

orb_long_signal = false
orb_short_signal = false
orb_long_from_cme = use_both_orb and orb_long_break_cme and not orb_long_done_cme
orb_short_from_cme = use_both_orb and orb_short_break_cme and not orb_short_done_cme
if not use_both_orb
    orb_long_signal := show_orb_signal and orb_long_break and not orb_long_done
    orb_short_signal := show_orb_signal and orb_short_break and not orb_short_done
else
    orb_long_signal := show_orb_signal and ((orb_long_break_cme and not orb_long_done_cme) or (orb_long_break_rth and not orb_long_done_rth))
    orb_short_signal := show_orb_signal and ((orb_short_break_cme and not orb_short_done_cme) or (orb_short_break_rth and not orb_short_done_rth))
if orb_long_signal and not use_both_orb
    orb_long_done := true
if orb_short_signal and not use_both_orb
    orb_short_done := true
if orb_long_break_cme and not orb_long_done_cme
    orb_long_done_cme := true
if orb_short_break_cme and not orb_short_done_cme
    orb_short_done_cme := true
if orb_long_break_rth and not orb_long_done_rth
    orb_long_done_rth := true
if orb_short_break_rth and not orb_short_done_rth
    orb_short_done_rth := true

vm_after_orb_long_ok  = not vm_only_after_orb or above_orb_high
vm_after_orb_short_ok = not vm_only_after_orb or below_orb_low

// ═══════════════════════════════════════════════════════════════════════════════
// VOLUME PROFILE: POC + Value Area (VAH / VAL) — from S/R Zones
// ═══════════════════════════════════════════════════════════════════════════════

var float[] _vp_vol = array.new_float(100)
vp_min_p   = ta.lowest(low, vp_lookback)
vp_max_p   = ta.highest(high, vp_lookback)
vp_range   = vp_max_p - vp_min_p
vp_bin_sz  = vp_range > 0 ? vp_range / math.max(1, vp_bins) : syminfo.mintick

array.fill(_vp_vol, 0.0)
for i = 0 to vp_lookback - 1
    typ_p = (high[i] + low[i] + close[i]) / 3.0
    idx = math.max(0, math.min(vp_bins - 1, int(vp_bin_sz > 0 ? math.floor((typ_p - vp_min_p) / vp_bin_sz) : 0)))
    array.set(_vp_vol, idx, array.get(_vp_vol, idx) + volume[i])

float _vp_max_vol = array.max(_vp_vol)
int _poc_bin = array.indexof(_vp_vol, _vp_max_vol)
poc_price = vp_min_p + (_poc_bin + 0.5) * vp_bin_sz

f_sum_vp(float[] arr, int n) =>
    var float s = 0.0
    s := 0.0
    for j = 0 to n - 1
        s := s + array.get(arr, j)
    s
float _vp_total = f_sum_vp(_vp_vol, vp_bins)
float _vp_target = _vp_total * (vp_value_pct / 100.0)
int _va_lo = _poc_bin
int _va_hi = _poc_bin
float _va_vol = array.get(_vp_vol, _poc_bin)
while _va_vol < _vp_target and (_va_lo > 0 or _va_hi < vp_bins - 1)
    float vol_above = _va_hi < vp_bins - 1 ? array.get(_vp_vol, _va_hi + 1) : 0.0
    float vol_below = _va_lo > 0 ? array.get(_vp_vol, _va_lo - 1) : 0.0
    if vol_above >= vol_below and _va_hi < vp_bins - 1
        _va_hi += 1
        _va_vol += array.get(_vp_vol, _va_hi)
    else if _va_lo > 0
        _va_lo -= 1
        _va_vol += array.get(_vp_vol, _va_lo)
    else
        break
vah_price = vp_min_p + (_va_hi + 1) * vp_bin_sz
val_price = vp_min_p + _va_lo * vp_bin_sz
va_height = vah_price - val_price
support_zone_bottom = val_price - va_height * (zone_ext_pct / 100.0)
resistance_zone_top = vah_price + va_height * (zone_ext_pct / 100.0)

long_zone_ok  = not use_zone_confirm or close <= vah_price
short_zone_ok = not use_zone_confirm or close >= val_price

// ═══════════════════════════════════════════════════════════════════════════════
// SIGNAL LOGIC (quant ATR + z-score in core + optional zone confirmation)
// ═══════════════════════════════════════════════════════════════════════════════

long_condition  = bull_cross and volume_ok and vwap_bullish and (rsi_ok_long or rsi_favors_long) and atr_ok and z_ok_long and bb_ok_long and macd_bullish and lr_ok_long and in_session and min_bars_ok_long and close_confirm_long and htf_bullish and long_zone_ok and vm_after_orb_long_ok
short_condition = bear_cross and volume_ok and vwap_bearish and (rsi_ok_short or rsi_favors_short) and atr_ok and z_ok_short and bb_ok_short and macd_bearish and lr_ok_short and in_session and min_bars_ok_short and close_confirm_short and htf_bearish and short_zone_ok and vm_after_orb_short_ok

reversal_long  = use_rsi and rsi_cross_up and volume_ok and volume_confirmed and vm_after_orb_long_ok
reversal_short = use_rsi and rsi_cross_down and volume_ok and volume_confirmed and vm_after_orb_short_ok

final_long  = long_condition or reversal_long or orb_long_signal
final_short = short_condition or reversal_short or orb_short_signal

if final_long
    last_long_bar := bar_index
    last_short_bar := bar_index
if final_short
    last_short_bar := bar_index
    last_long_bar := bar_index

// ═══════════════════════════════════════════════════════════════════════════════
// PLOTS
// ═══════════════════════════════════════════════════════════════════════════════

plot(ma_fast, "Fast MA", color=color.new(color.blue, 0), linewidth=2)
plot(ma_slow, "Slow MA", color=color.new(color.orange, 0), linewidth=2)
plot(use_vwap ? vwap_daily : na, "VWAP", color=color.new(color.purple, 0), linewidth=1)
plot(use_bb ? bb_upper : na, "BB Upper", color=color.new(color.teal, 50), linewidth=1)
plot(use_bb ? bb_lower : na, "BB Lower", color=color.new(color.teal, 50), linewidth=1)
plot(use_bb ? bb_basis : na, "BB Basis", color=color.new(color.teal, 70), linewidth=1)

plot(show_poc ? poc_price : na, "POC", color=poc_color, linewidth=2)
plot(show_vah_val ? vah_price : na, "VAH", color=vah_color, linewidth=1)
plot(show_vah_val ? val_price : na, "VAL", color=val_color, linewidth=1)

plot(show_orb_lines and not use_both_orb and not na(orb_high_1) ? orb_high_1 : na, "ORB High", color=orb_high_color, linewidth=2)
plot(show_orb_lines and not use_both_orb and not na(orb_low_1) ? orb_low_1 : na, "ORB Low", color=orb_low_color, linewidth=2)
plot(show_orb_lines and use_both_orb and in_cme and not na(orb_high_cme) ? orb_high_cme : na, "ORB CME High", color=orb_high_color, linewidth=2)
plot(show_orb_lines and use_both_orb and in_cme and not na(orb_low_cme) ? orb_low_cme : na, "ORB CME Low", color=orb_low_color, linewidth=2)
plot(show_orb_lines and use_both_orb and in_rth and not na(orb_high_rth) ? orb_high_rth : na, "ORB RTH High", color=orb_rth_high_color, linewidth=2)
plot(show_orb_lines and use_both_orb and in_rth and not na(orb_low_rth) ? orb_low_rth : na, "ORB RTH Low", color=orb_rth_low_color, linewidth=2)

// ORB range rectangle (whole opening range shaded; use time for left/right to avoid bar index limit)
var box _box_orb = na
var box _box_orb_rth = na
if show_orb_rect and not use_both_orb and not na(orb_range_start_time) and not na(orb_high_1)
    if na(_box_orb)
        _box_orb := box.new(orb_range_start_time, orb_high_1, time, orb_low_1, xloc=xloc.bar_time, border_color=orb_rect_border, border_width=1, bgcolor=orb_rect_fill)
    else
        box.set_left(_box_orb, orb_range_start_time)
        box.set_right(_box_orb, time)
        box.set_top(_box_orb, orb_high_1)
        box.set_bottom(_box_orb, orb_low_1)
        box.set_bgcolor(_box_orb, orb_rect_fill)
        box.set_border_color(_box_orb, orb_rect_border)
else if not use_both_orb
    if not na(_box_orb)
        box.delete(_box_orb)
        _box_orb := na
if show_orb_rect and use_both_orb
    if in_cme and not in_rth and not na(orb_range_start_cme) and not na(orb_high_cme)
        if na(_box_orb)
            _box_orb := box.new(orb_range_start_cme, orb_high_cme, time, orb_low_cme, xloc=xloc.bar_time, border_color=orb_rect_border, border_width=1, bgcolor=orb_rect_fill)
        else
            box.set_left(_box_orb, orb_range_start_cme)
            box.set_right(_box_orb, time)
            box.set_top(_box_orb, orb_high_cme)
            box.set_bottom(_box_orb, orb_low_cme)
            box.set_bgcolor(_box_orb, orb_rect_fill)
            box.set_border_color(_box_orb, orb_rect_border)
    else if not na(_box_orb)
        box.delete(_box_orb)
        _box_orb := na
    if in_rth and not na(orb_range_start_rth) and not na(orb_high_rth)
        if na(_box_orb_rth)
            _box_orb_rth := box.new(orb_range_start_rth, orb_high_rth, time, orb_low_rth, xloc=xloc.bar_time, border_color=color.new(orb_rth_high_color, 50), border_width=1, bgcolor=color.new(orb_rth_high_color, 88))
        else
            box.set_left(_box_orb_rth, orb_range_start_rth)
            box.set_right(_box_orb_rth, time)
            box.set_top(_box_orb_rth, orb_high_rth)
            box.set_bottom(_box_orb_rth, orb_low_rth)
    else if not na(_box_orb_rth)
        box.delete(_box_orb_rth)
        _box_orb_rth := na

left_edge  = bar_index - vp_lookback
right_edge = bar_index
var box _box_va  = na
var box _box_sup = na
var box _box_res = na
if show_vah_val and show_va_rect
    if na(_box_va)
        _box_va := box.new(left_edge, vah_price, right_edge, val_price, border_color=color.new(vah_color, 70), border_width=1, bgcolor=va_fill)
    else
        box.set_left(_box_va, left_edge)
        box.set_right(_box_va, right_edge)
        box.set_top(_box_va, vah_price)
        box.set_bottom(_box_va, val_price)
        box.set_bgcolor(_box_va, va_fill)
else if not na(_box_va)
    box.delete(_box_va)
    _box_va := na
if show_support_zone
    if na(_box_sup)
        _box_sup := box.new(left_edge, val_price, right_edge, support_zone_bottom, border_color=color.new(val_color, 70), border_width=1, bgcolor=support_fill)
    else
        box.set_left(_box_sup, left_edge)
        box.set_right(_box_sup, right_edge)
        box.set_top(_box_sup, val_price)
        box.set_bottom(_box_sup, support_zone_bottom)
        box.set_bgcolor(_box_sup, support_fill)
else if not na(_box_sup)
    box.delete(_box_sup)
    _box_sup := na
if show_resistance_zone
    if na(_box_res)
        _box_res := box.new(left_edge, resistance_zone_top, right_edge, vah_price, border_color=color.new(vah_color, 70), border_width=1, bgcolor=resistance_fill)
    else
        box.set_left(_box_res, left_edge)
        box.set_right(_box_res, right_edge)
        box.set_top(_box_res, resistance_zone_top)
        box.set_bottom(_box_res, vah_price)
        box.set_bgcolor(_box_res, resistance_fill)
else if not na(_box_res)
    box.delete(_box_res)
    _box_res := na

zone_lbl_sz = zone_label_sz == "tiny" ? size.tiny : zone_label_sz == "small" ? size.small : size.normal
var label _l_poc = na
var label _l_sup = na
var label _l_res = na
if show_zone_labels
    if na(_l_poc) and show_poc
        _l_poc := label.new(bar_index, poc_price, "POC — High volume", style=label.style_label_left, color=color.new(poc_color, 70), textcolor=color.black, size=zone_lbl_sz)
    else if show_poc
        label.set_xy(_l_poc, bar_index, poc_price)
        label.set_text(_l_poc, "POC — High volume")
    else if not na(_l_poc)
        label.delete(_l_poc)
        _l_poc := na
    if na(_l_sup) and show_support_zone
        _l_sup := label.new(bar_index, (val_price + support_zone_bottom) / 2, "Support zone", style=label.style_label_left, color=color.new(support_fill, 60), textcolor=color.black, size=zone_lbl_sz)
    else if show_support_zone
        label.set_xy(_l_sup, bar_index, (val_price + support_zone_bottom) / 2)
        label.set_text(_l_sup, "Support zone")
    else if not na(_l_sup)
        label.delete(_l_sup)
        _l_sup := na
    if na(_l_res) and show_resistance_zone
        _l_res := label.new(bar_index, (vah_price + resistance_zone_top) / 2, "Resistance zone", style=label.style_label_left, color=color.new(resistance_fill, 60), textcolor=color.black, size=zone_lbl_sz)
    else if show_resistance_zone
        label.set_xy(_l_res, bar_index, (vah_price + resistance_zone_top) / 2)
        label.set_text(_l_res, "Resistance zone")
    else if not na(_l_res)
        label.delete(_l_res)
        _l_res := na

plotshape(show_arrows and final_long,  title="Long",  style=shape.triangleup,   location=location.belowbar, color=color.green, size=size.small)
plotshape(show_arrows and final_short, title="Short", style=shape.triangledown, location=location.abovebar, color=color.red,   size=size.small)
if show_arrows and final_long
    orb_long_txt = orb_long_signal ? (use_both_orb ? (orb_long_from_cme ? "ORB LONG (CME)" : "ORB LONG (RTH)") : "ORB LONG") : "LONG"
    label.new(bar_index, low, orb_long_txt, style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)
if show_arrows and final_short
    orb_short_txt = orb_short_signal ? (use_both_orb ? (orb_short_from_cme ? "ORB SHORT (CME)" : "ORB SHORT (RTH)") : "ORB SHORT") : "SHORT"
    label.new(bar_index, high, orb_short_txt, style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)

if alert_on_signal and final_long
    alert("VM Signals: LONG signal", alert.freq_once_per_bar)
if alert_on_signal and final_short
    alert("VM Signals: SHORT signal", alert.freq_once_per_bar)
alertcondition(final_long,  title="Long Signal",  message="Volume & Math: LONG")
alertcondition(final_short, title="Short Signal", message="Volume & Math: SHORT")
